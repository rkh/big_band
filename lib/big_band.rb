require "sinatra/base"
#require "monkey-lib"
require "set"

# BigBand is a collection of Sinatra extensions and offers better sinatra integration for common tools.
# It is pluggable and each extension can be used in stand alone mode.
#
# The main features are:
# * Routes as first class objects
# * Better handling of #set: Merges hashes, more hooks
# * Better compass integration
# * YAML config files mapping to set (overwriting present values/methods is prevented)
# * Rails-like helpers, like content_for
# * Unicorn and Rainbows integration
# * Smart code reloader only reloading changed files and getting rid of old routes
# * Sass extensions
# * Routes for inspection in development mode
# * Helpers and configuration for Bacon, RSpec, Test::Spec and Test::Unit
# * Tasks listing all routes for Monk and Rake.
# * YARD: Add Sinatra routes to generated documentation
#
# Planned features:
# * More template helpers
# * ORM integration
# * MSpec integration
#
# == Usage
# 
# Using all BigBand features:
#
#   require "sinatra/big_band"
#   class Example < Sinatra::BigBand
#     # Yay, BigBand!
#   end
#
# Or you may use the extension style:
#
#   class AnotherExample < Sinatra::Base
#     register Sinatra::BigBand
#   end
#
# Or for the lazy folks (if you use classic style):
#
#   require "sinatra"
#   require "sinatra/big_band"
#   # Yay, BigBand!
#
# Sinatra::BigBand is just an alias for BigBand. It was introduced manly to (in my opinion) have prettier
# class signatures. First "class Example < Sinatra::BigBand" looks like Sinatra "class Example < BigBand", lets
# give some credit to our beloved framework. Also, Sinatra::BigBand seems more akin to Sinatra::Base, Sinatra::Application
# and Sinatra::Default, than just BigBand. Other than that I do not plan to move BigBand completely into Sinatra simply
# to avoid more nesting. Last, but no least, the Sinatra docs sugest placing extensions inside Sinatra.
# 
# Using just your favorite BigBand features:
#
#   require "big_band"
#   class Example < Sinatra::Base
#     register BigBand::SomeFeature
#     # Yay, SomeFeature!
#   end
#
# Or, if you like a more handy syntax:
#
#   require "sinatra/big_band"
#   class Example < Sinatra::BigBand :SomeFeature, MyStuff::Extension, :development => :DevelopmentOnlyFeature
#     # Yay, BigBand::SomeFeature!
#     # Yay, MyStuff::Extension!
#     # Yay, BigBand::DevelopmentOnlyFeature, if this is development mode!
#   end
#
# Loading all but one feature:
#
#   require "sinatra/big_band"
#   class Example < Sinatra::BigBand :except => :SomeFeature
#     # Yay, all but BigBand::SomeFeature!
#   end
#
# Or just your favorite feature without you subclassing Sinatra::Base manually:
#
#   require "sinatra"
#   require "big_band/some_feature"
#   Sinatra::Application.register BigBand::SomeFeature
#   # Yay, BigBand::SomeFeature!
class BigBand < Sinatra::Base

  # Classes generated by BigBand.generate_class will be extended
  # with this class.
  module Generated

    attr_reader :big_band_extensions, :big_band_constructor

    # Adds extensions to subclass
    def inherited(klass)
      super
      BigBand.applications << klass
      BigBand.load_extensions(klass, *big_band_extensions)
    end

    # Use Generated#name for inspection.
    def inspect
      name
    end

    # Nice output for inspect and friends:
    #   foo = Class.new BigBand(:SomeExtension)
    #   foo.name # => BigBand(:SomeExtension)
    #   Foo = foo
    #   foo.name # => Foo
    def name
      real_name = super
      real_name.empty? ? big_band_constructor : real_name
    end

  end

  extend Generated

  def self.applications
    @applications ||= []
  end

  # Extensions to load.
  def self.big_band_extensions
    default_extensions
  end

  # Generates a class for the given extensions. Note that this class is ment to be
  # subclassed rather than used directly. Given extensione will only be available for
  # subclasses.
  #
  #   class Foo < BigBand.generate_class(:except => :SomeExtension)
  #   end
  def self.generate_class(*options)
    @generated_classes ||= {setify_parameters([]) => BigBand}
    @generated_classes[setify_parameters(options)] ||=  Class.new(Sinatra::Base) do
      extend BigBand::Generated
      @big_band_extensions = options
      @big_band_constructor = "BigBand(#{options.map { |o| o.inspect}.join ", "})"
    end
  end

  # Adds extensions to a Sinatra application:
  #
  #   class MyApp < Sinatra::Base
  #   end
  #
  #   BigBand.load_extensions MyApp, :SomeExtension, :development => :AnotherExtension
  def self.load_extensions(klass, *extensions)
    extensions = default_extensions if extensions.empty?
    extensions.flatten.each do |extension|
      if extension.respond_to? :each_pair
        extension.each_pair do |key, value|
          values = [value].flatten
          case key
          when :production, :test, :development
            klass.configure(key) { BigBand.load_extensions(klass, *values) }
          when :except
            exts = @nonenv_extensions.reject { |e| values.include? e }
            exts << @env_extensions.inject({}) do |accepted, (env, list)|
              accepted.merge env => list.reject { |e| values.include? e }
            end
            load_extensions(klass, *exts)
          else raise ArgumentError, "unknown key #{key.inspect}"
          end
        end
      else
        klass.register module_for(extension)
      end
    end
  end

  # Returns the module for a given extension identifier:
  #
  #   BigBand.module_for :BasicExtension # => BigBand::BasicExtension
  #   BigBand.module_for Array           # => Array
  #   BigBand.module_for "Foo::Bar"      # => BigBand::Foo::Bar or Foo::Bar or raises an exception
  def self.module_for(extension)
    case extension
    when Module then extension
    when String then extension.split("::").inject(self) { |klass, name| klass.const_get name }
    when Symbol then const_get(extension)
    end
  end

  def self.setify_parameters(args)
    case args
    when Hash then args.inject({}) { |h,(k,v)| h k => setify_parameters(v) }
    when Array then args.flatten.to_set
    else args
    end
  end

  # Default extensions that will be used whenever you subclass BigBand. You can also use this to create
  # your own extension collection:
  #
  #   class MyExtensions < BigBand(:except => :ExtensionIDontLike)
  #     default_extension FunkyExtension, :development => DevExtension
  #   end
  #
  # Note: If given a string or symbol, it will also try to setup an autoloader:
  #
  #   MyExtensions.default_extensions :Foo
  def self.default_extensions(*extensions)
    return @default_extensions if @default_extensions and extensions.empty?
    @nonenv_extensions ||= []
    @env_extensions ||= {:development => []}
    extensions.each do |extension|
      if extension.respond_to? :each_pair
        extension.each_pair { |env, exts| (@env_extensions[env] ||= []).push(*exts) }
      else
        @nonenv_extensions.push(*extension)
      end
    end
    @default_extensions = [@nonenv_extensions, @env_extensions].flatten
  end

  def self.default_extension(name, path = nil, env = nil)
    autoload name, path if path
    default_extensions(env ? {env => name} : name)
  end

  default_extension :AdvancedRoutes,  "big_band/advanced_routes"
  default_extension :BasicExtensions, "big_band/basic_extensions"
  default_extension :Compass,         "big_band/compass"
  default_extension :ConfigFile,      "big_band/config_file"
  default_extension :MoreHelpers,     "big_band/more_helpers"
  default_extension :MoreServer,      "big_band/more_server"
  default_extension :Reloader,        "big_band/reloader", :development
  default_extension :Sass,            "big_band/sass"
  default_extension :WebInspector,    "big_band/web_inspector", :development

end

# Shorthand for BigBand.generate_class
def BigBand(*options)
  BigBand.generate_class(*options)
end

module Sinatra
  BigBand = ::BigBand
  class Base
    class << self
      alias register_without_big_band register
      def register(*extensions, &block)
        big_band, normal = extensions.partition { |e| e.respond_to? :big_band_extensions }
        big_band.each { |e| e.load_extensions self }
        register_without_big_band(*normal, &block)
        extensions
      end
    end
  end
  module Delegator
    # Hooks into Sinatra to allow easy integration with "require 'sinatra'".
    def self.included(klass)
      BigBand.inherited(Sinatra::Application)
      Sinatra::Application.extensions.each do |ext|
        delegate(*ext.delegations) if ext.respond_to? :delegations
      end
    end
  end
end

# If require "sinatra" came before require "big_band" Sinatra::Delegator.included has not been called.
Sinatra::Delegator.included(self) if is_a? Sinatra::Delegator